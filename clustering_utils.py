# -*- coding: utf-8 -*-
"""clustering_utils.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sE8Oi6GMkSaDzIEd8H9q6YaEfvCdPdW4

1. インポート・環境設定（ロギング含む）
2. データロード・前処理（主に標準化・スケーリング）
3. クラスタリングモデル学習（KMeans, DBSCAN, 階層型など対応）
4. モデル評価（シルエットスコア、エルボー法プロットなど）
5. クラスタリング結果の可視化（2D/3Dプロット）
6. ファイル保存・読込（モデル保存）
7. ファイルアップロード支援
"""

# ================================
# インポートと環境設定
# ================================

import os
import joblib
import logging
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans, DBSCAN, AgglomerativeClustering
from sklearn.metrics import silhouette_score
from google.colab import drive
from google.colab import files

from typing import Any, Dict, List, Optional, Tuple, Union

# ログ設定
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)
# ================================
# データロード・前処理
# ================================

def load_csv_data(file_path: str, features_to_drop: Optional[List[str]] = None) -> pd.DataFrame:
    """CSVファイルからデータをロード"""
    try:
        if not os.path.exists(file_path) and '/content/drive' not in file_path:
            file_path = os.path.join('/content/drive/MyDrive/', file_path)

        df = pd.read_csv(file_path)
        logger.info(f"📊 データロード完了: {df.shape}")

        if features_to_drop:
            df = df.drop(columns=features_to_drop)

        return df
    except Exception as e:
        logger.error(f"❌ CSVロード失敗: {e}")
        return None

def standardize_data(X: pd.DataFrame) -> pd.DataFrame:
    """特徴量を標準化（平均0、分散1に）"""
    try:
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        logger.info("✅ 特徴量標準化完了")
        return pd.DataFrame(X_scaled, columns=X.columns)
    except Exception as e:
        logger.error(f"❌ 標準化失敗: {e}")
        return None
# ================================
# クラスタリングモデル学習
# ================================

def train_clustering_model(X: pd.DataFrame, model_type: str = "kmeans",
                           params: Optional[Dict] = None) -> Any:
    """指定されたクラスタリングモデルで学習"""
    logger.info(f"🔄 クラスタリングモデル学習開始: {model_type}")

    if model_type.lower() == "kmeans":
        model = KMeans()
    elif model_type.lower() == "dbscan":
        model = DBSCAN()
    elif model_type.lower() == "agglomerative":
        model = AgglomerativeClustering()
    else:
        logger.error(f"❌ 未対応のモデルタイプ: {model_type}")
        return None

    if params:
        model.set_params(**params)

    model.fit(X)
    logger.info("✅ モデル学習完了")
    return model
# ================================
# クラスタリングモデル評価
# ================================

def evaluate_clustering_model(X: pd.DataFrame, labels: np.ndarray) -> float:
    """クラスタリングのシルエットスコアを計算"""
    try:
        score = silhouette_score(X, labels)
        logger.info(f"📈 シルエットスコア: {score:.4f}")
        return score
    except Exception as e:
        logger.error(f"❌ シルエットスコア計算失敗: {e}")
        return -1

def plot_elbow_method(X: pd.DataFrame, max_k: int = 10) -> None:
    """KMeansの最適クラスタ数を探すエルボー法プロット"""
    try:
        distortions = []
        K = range(1, max_k + 1)
        for k in K:
            kmeans = KMeans(n_clusters=k, random_state=42)
            kmeans.fit(X)
            distortions.append(kmeans.inertia_)

        plt.figure(figsize=(8, 4))
        plt.plot(K, distortions, 'bx-')
        plt.xlabel('k')
        plt.ylabel('Distortion')
        plt.title('Elbow Method for Optimal k')
        plt.show()
    except Exception as e:
        logger.error(f"❌ エルボー法プロット失敗: {e}")
# ================================
# クラスタリング結果可視化
# ================================

def plot_clusters_2d(X: pd.DataFrame, labels: np.ndarray) -> None:
    """2次元プロットでクラスタリング結果を可視化"""
    try:
        pca = PCA(n_components=2)
        components = pca.fit_transform(X)

        df_plot = pd.DataFrame({
            "PC1": components[:, 0],
            "PC2": components[:, 1],
            "Cluster": labels
        })

        fig = px.scatter(df_plot, x="PC1", y="PC2", color=df_plot["Cluster"].astype(str),
                         title="2D PCA Cluster Plot")
        fig.show()
    except Exception as e:
        logger.error(f"❌ 2Dクラスタリングプロット失敗: {e}")

def plot_clusters_3d(X: pd.DataFrame, labels: np.ndarray) -> None:
    """3次元プロットでクラスタリング結果を可視化"""
    try:
        pca = PCA(n_components=3)
        components = pca.fit_transform(X)

        df_plot = pd.DataFrame({
            "PC1": components[:, 0],
            "PC2": components[:, 1],
            "PC3": components[:, 2],
            "Cluster": labels
        })

        fig = px.scatter_3d(df_plot, x="PC1", y="PC2", z="PC3", color=df_plot["Cluster"].astype(str),
                            title="3D PCA Cluster Plot")
        fig.show()
    except Exception as e:
        logger.error(f"❌ 3Dクラスタリングプロット失敗: {e}")
# ================================
# ファイル保存・読込
# ================================

def save_model_to_drive(model: Any, relative_path: str) -> None:
    """クラスタリングモデルをGoogle Driveに保存"""
    try:
        full_path = os.path.join('/content/drive/MyDrive/', relative_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        joblib.dump(model, full_path)
        logger.info(f"✅ モデル保存完了: {full_path}")
    except Exception as e:
        logger.error(f"❌ モデル保存失敗: {e}")

def load_model_from_drive(relative_path: str) -> Any:
    """Google Driveからクラスタリングモデルをロード"""
    try:
        full_path = os.path.join('/content/drive/MyDrive/', relative_path)
        return joblib.load(full_path)
    except Exception as e:
        logger.error(f"❌ モデルロード失敗: {e}")
        return None
# ================================
# ファイルアップロード支援
# ================================

def upload_file_from_local() -> Dict[str, Any]:
    """ローカルPCからファイルをアップロード"""
    logger.info("📂 ローカルファイルをアップロードしてください")
    uploaded = files.upload()
    logger.info(f"✅ アップロード完了: {list(uploaded.keys())}")
    return uploaded